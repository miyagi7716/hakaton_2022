# Задание
Перед вами содержимое данного вам репозитория. Сделайте его форк. Сам форк — склонируйте.  
В папке `rtl` вы можете найти эталонный проект устройства, спецификацию которого вы сможете прочесть ниже. В папке `tb` находится тестбенч, а так же модуль-заготовка, в котором вам необходимо дописать ассершены по спецификации на устройство, которые позволят убедиться в работоспособности как эталонного дизайна, так и множества других его реализаций, часть из которых содержит ошибки.  
Эталонный модуль устройства и тестбенч даны вам, чтоб вы могли отладить ваши ассершены до отправки их на проверку. Если во время симуляции эталонного модуля вы видите нарушение ассершена — значит скорее всего вы где-то ошиблись (правда возможно так же и то, что вы нашли ошибку в эталонном модуле).
Вам необходимо править только модуль `tb/vendmachine_assertions.sv`, если вы будете создавать проект внутри данной папки, убедитесь, что вы не фиксируете файлы проекта.  
После того, как вы добавили ассершены, вам необходимо открыть pull-request — запустится автоматизированный запуск тестов. По окончанию тестирования вы сможете скачать архив с логами и времянками, по которым сможете понять на каких модулях сработали ваши ассершены, и проверить корректно ли они сработали.
Ваша цель — найти как можно больше модулей с ошибками в коде порседством написанных вами ассершенов, и попытаться понять в чем заключается ошибка.  
Вы не знаете сколько есть ошибок. Вы не знаете есть ли они вообще. Вы не можете посмотреть на код модулей. Дерзайте!  
# gtkwave
В процессе работы вам потребуется изучать временные диаграммы. Они будут открываться в программе [gtkwawe](https://sourceforge.net/projects/gtkwave/) (скачайте её).  
Сам запуск `gtkwave` происходит из терминала следующей командой:
```bash
gtkwave -F <your_waveform_file.fsdb>
```
В открывшемся окне слева вы увидите вкладку `SST`, внутри которой расположен объект `testbench`, внутри которого есть объект `dut`, внутри которого объект `dut_sva`. Кликните ПКМ по `dut_sva`, затем выберите `Recurse Import`→`Append`.  
В папке `gtkwave_filters` находятся два файла, которые позволят при просмотре временной диаграммы в программе gtkwave отображать регистр `state` и все сигналы, использующие тип `coin_nominal` в текстовом виде (вместо `state==3'b000` отображать `state==IDLE`). Для этого необходимо кликнуть ПКМ по нужному сигналу → `Data Format` → `Translate Filter File` → `Enable and Select`. Откроется окно `Select Signal Filter`. Кликните по кнопке `Add Filter`. Выберите соответствующий файл-фильтр. Этот файл отобразится в предыдущем окне. Выберите этот файл, убедитесь что он выделился, и жмите на OK. Отображение сигнала должно смениться с двоичного на символьное.  
# Описание устройства
Имеется торговый автомат со следующим прототипом:
``` SystemVerilog
module vendmachine#(
  parameter COIN_STORAGE_VOLUME = 128
)(
  input
          logic         clk_i,
          logic         soft_reset_n_i,
          logic         hard_areset_n_i,
          logic [7:0]   slave_data_coin_i,      // \
          logic         slave_valid_coin_i,     //  - Интерфейс входящих монет
  output  logic         slave_ready_coin_o,     // /

  // Items pick interface
  input
          logic [7:0]   slave_id_item_i,        // \
          logic         slave_valid_item_i,     //  - Интерфейс выбора товара
  output  logic         slave_ready_item_o,     // /

  // Items eject interface
          logic [7:0]   master_id_item_o,       // \
          logic         master_valid_item_o,    //  - Интерфейс выдачи товара
  input   logic         master_ready_item_i,    // /  << должен быть всегда равен 1

  // Exchange interface
  output
          logic [7:0]   master_data_exchange_o, // \
          logic         master_valid_exchange_o,//  - Интерфейс выдачи сдачи
  input   logic         master_ready_exchange_i // / << должен быть всегда равен 1

);
```
Автомат принимает монеты номиналом 1, 2, 5, 10 рублей. Разумеется, вы можете опустить внутрь и другие круглые предметы, равно как и монеты других стран, но автомат автоматически вернёт их обратно. Принятые автоматом монеты формируют ваш депозит. Вы можете приобрести товар, если депозит равен, или превышает стоимость выбранного вами товара. В противном случае, автомат возвращает депозит (возможно, монетами других номиналов). В случае, если хранилище какого-то типа монет заполнено, автомат перестаёт принимать этот тип монет. Если заполнились все хранилища монет при ненулевом депозите, и вы не выбрали товар после того, как опустили предыдущую монету, автомат вернет депозит, т.к. больше не может принимать монеты.  
В случае заполнения хранилища монет при нулевом депозите (был куплен товар сразу после заполнения хранилища) или если число монет по любому из номиналов опустилось ниже 10 (появляется потенциальная проблема с выдачей сдачи) или если закончились товары, он переходит в состояние `MAINTENANCE`, в котором не принимает монеты, пока не придёт сотрудник сервисной службы.  
В случае отключения автомата от сети, формируется программный сброс, а автомат переходит на работу от аккумулятора, запаса которого гарантированно хватит на завершение выдачи товара и сдачи (в случае иных состояний автомата при ненулевом депозите, автомат вернет депозит). После выполнения всех операций, автомат переходит в состояние `MAINTENANCE`.  
Сигналы `master_ready_item_i` и `master_ready_exchange_i`, подаваемые на автомат, должны всегда быть равны единице (выдача товара и монет происходит сразу и без задержек).

# Переходы конечного автомата между состояниями
![](.img/fsm.jpg)

* Автомат находится в состоянии `IDLE`:
  * В случае внутреннего сигнала сброса при нулевом депозите, либо если не осталось товаров, хранилища всех типов монет заполнены, число монет в хранилище по любому из номиналов меньше 20, или если происходит программный сброс при нулевом депозите → переход в состояние `MAINTENANCE`;
  * В случае подачи предмета в монетоприёмник → переход в состояние `PROCESS`;
  * В случае нажатия на кнопку выбора товара или кнопку возврата монет → переход в состояние `SERV`;
  * В противном случае, автомат остаётся в состоянии `IDLE`;

* Автомат находится в состоянии `PROCESS`:
  * В случае, если была опущена подходящая монетка (и хранилище этого типа монет не полно) → переход в состояние `INCREMENT`;
  * В противном случае → переход в состояние `EJECT`;

* Автомат находится в состоянии `INCREMENT`:
  * Переход в состояние `IDLE`;

* Автомат находится в состоянии `SERV`:
  * Переход в состояние `EJECT`;

* Автомат находится в состоянии `MAINTENANCE`:
  * В случае ввода сервисной операции (одновременный ввод монет всех поддерживаемых типов, что возможно сделать только открыв автомат) → переход в состояние `EJECT`;
  * В противном случае автомат остается в состоянии `MAINTENANCE`;

* Автомат находится в состоянии `EJECT`:
  * Пока не завершится выдача всех монет → переход в состояние `EJECT`;
  * В противном случае → переход в состояние `IDLE`.

# Действия, производимые автоматом в различных состояниях
## Состояние PROCESS
В случае, если хранилище монет какого-то типа полно, либо если в автомат подана монета неподходящего типа (или не монета вовсе), автомат возвращает эту монету.  
Возврат монеты происходит путём поднятия флага возврата монеты (бита `INPUT_COIN` в регистре `eject_source`) и перехода в состояние `EJECT`.  
В противном случае, автомат помещает монету в монетоприёмник, и переходит в состояние `INCREMENT`

## Состояние EJECT
В состоянии `EJECT` может происходить выдача монет из следующих источников:

1. Только что опущенная монета;
2. Сдача из монет, хранящихся в хранилище;
3. Все имеющиеся в хранилище монеты.

Выдача происходит по одной монете за транзакцию шины `axi stream`.

## Состояние SERV
В состоянии `SERV` автомат проверяет, хватает ли текущего баланса для покупки товара, имеется ли такой товар и хватит ли у него монет для выдачи сдачи после покупки. Если хоть одна из проверок не будет завершена успехом, автомат возвращает депозит (возможно, монетами другого номинала). Возврат депозита происходит через поднятие фалага `EXCHANGE` в регистре `eject_source`.
В случае успешного завершения всех проверок, пользователю выдаётся его товар (в виде транзакции `axi_stream`) и сдача (путём выставления флага `EXCHANGE` в регистре `eject_source` и перехода в состояние `EJECT`).  
Кроме того, в качестве товара, пользователь может выбрать “Возврат монет” (на уровне шины `axi stream` это означает, что придёт транзакция с идентификатором `8'b1111_1111`. В этом случае, поведение будет аналогично поведению, при несовпадении какого-либо из условий при продаже товара, и пользователь вернёт себе деньги.

## Сигнал сброса
При отключении питания, автомат переходит на питание от внутреннего источника, и на вход логики приходит сигнал `soft_reset_n`. По приходу сигнала сброса, автомат региструет его. Реакция автомата происходит на регистрованный сигнал сброса и только в состоянии `IDLE`. В остальных состояниях, автомат ждёт завершения операции и перехода в состояние `IDLE`, после которого он среагирует на сброс и попадёт в состояние `Reset`.  
При обнаружении `soft_reset`, автомат вернёт текущий баланс пользователя, в случае если уже не была инициирована процедура выдачи товара / возврата монет.  
После подачи питания на отключённый автомат, генерируется сигнал `hard_areset_n`, который сразу же сбрасывает все регистры автомата, а сам автомат после этого переходит в состояние `MAINTENANCE`, ожидая прихода сотрудника сервисной службы.  

# Архитектурные регистры
## state
``` SystemVerilog
typedef enum logic [2:0] {
  IDLE        = 3'd0,
  PROCESS     = 3'd1,
  INCREMENT   = 3'd2,
  SERV        = 3'd3,
  EJECT       = 3'd4,
  MAINTENANCE = 3'd5
 } State;
```
Переход между состояниями организован в соответствии с графом переходов в спецификации.  
Важно отметить приоритет при переходе из состояния `IDLE`:  
* В первую очередь, если дальнейшие продажи невозможны (закончился товар или сдача, не осталось места для других монет или выполнился программный сброс при нулевом депозите), происходит переход в состояние `MAINTENANCE`. Если в хранилище закончилось место или произошел программный сброс при ненулевом депозите, произойдет переход в состояние `SERV` вне зависимости от того, пришел ли запрос на выбор товара. Если он пришел, произведется попытка выдачи товара, в противном случае произойдет автоматический возврат депозита.
* Следующим состоянием в приоритете стоит обработка опущенной монеты (переход в состояние `PROCESS`)
* В последнюю очередь происходит переход в `SERV` по приходу запроса на выдачу товара / возврата депозита.

Логика интерфейсов `axi stream` построена так, чтобы не происходило одновременных транзакций по интерфейсам `item`/`coin`, если автомат видит `valid` на интерфейсе монет, он опускает `ready` интерфейса товаров.

## internal_reset
``` SystemVerilog
logic internal_reset;
```
Внутренний сигнал сброса. Используется для перехода в состояние `MAINTENANCE` из состояния `IDLE` при нулевом депозите, и в состоние `SERV` (возврат монет) из состояния `IDLE` при ненулевом депозите. Взводится в `1` по приходу сигнала `soft_reset_n`, опускается в `0` из состояния `MAINTENANCE`.

## maintenance_reset
``` SystemVerilog
logic maintenance_reset;
```
Сигнал сервисного сброса. Используется для выхода из состояния `MAINTENANCE` и пополнения хранилища после его опустошения посредством серсвисного запроса. Взводится при появлении сервисного запроса (опускание монет всех номиналов (`slave_data_coin_i=8'd18`), такая транзакция валидна только из состояния `MAINTENANCE`). Сбрасывается после выхода из состояния `EJECT` (после того, как работник забрал монеты из хранилища и поместил новую пачку с монетами).

## eject_source
``` SystemVerilog
logic [2:0] eject_source;
typedef enum logic [1:0] {
  INPUT_COIN  = 2'd0,
  EXCHANGE    = 2'd1,
  STORAGE     = 2'd2
} eject_source_bit;
```
Сигнал источников для выдачи монет.  
Источников выдачи три: `INPUT_COIN`(нулевой бит), `EXCHANGE`(первый бит), `STORAGE`(второй бит).  
В первую очередь, выдаётся только что опущенная монета, если таковое требуется. Это может произойти в следующих случаях:
* будучи в состоянии `IDLE` опустили монету неподходящего номинала;
* находясь в состоянии `MAINTENANCE` опустили сервисную монету номиналом 18 (монеты всех 4х номиналов);
* опустили монету, под которую в хранилище уже нет места.

Во всех случаях, при попадании в состояние `EJECT`, автомат вернёт такую монету. Поскольку для возврата монеты требуется одна транзакция, и возврат монеты имеет высший приоритет в выдаче, по переходу в состояние `EJECT`, этот источник можно сразу же сбрасывать.  
Источник `EXCHANGE` используется для возврата депозита пользователя, либо выдачи сдачи. Возврат депозита может произойти по многим причинам:
* Запрос от пользователя (выбран товар с `id=8'b1111_1111`);
* Стоимость выбранного пользователем товара превышает имеющийся ненулевой депозит или же выбранный товар закончился (опять же, при ненулевом депозите);
* Во время пополнения депозита хранилище монет переполнилось (однако, если сразу после перехода в состояние `IDLE`, пользователь выберет товар, автомат произведёт попытку его выдачи, в противном случае на следующий такт произойдёт возврат депозита);
* Если произошёл программный сброс при ненулевом депозите.

Сдача выдаётся после успешного завершения покупки, выдавая разницу между депозитом и стоимостью выданного товара.  
Последним источником является `STORAGE` — опустошение хранилища работником. Источник взводится при переходе в состояние `MAINTENANCE`.

## current_coin
``` SystemVerilog
logic [7:0] current_coin;
```
Регистр, хранящий значение текущей опущенной монеты. В случае возврата монеты, регистр очищается.

## current_item
``` SystemVerilog
logic [7:0] current_item
```
Регистр, хранящий выбранный товар. В случае выдачи товара, регистр очищается, в случае переполнения хранилища при ненулевом балансе (а также программном сбросе при отсутствии запроса на товар со стороны пользователя), через данный регистр имитируется выбор пользователем опции "возврат монет".

## coin_storage
``` SystemVerilog
logic [7:0] coin_storage[4];

typedef enum logic [2:0] {
  RUBBLE      = 3'd0,
  TWO_RUBBLES = 3'd1,
  FIVE_RUBBLES= 3'd2,
  TEN_RUBBLES = 3'd3,
  SERVICE     = 3'd4, // Эти значения не используются
  INCORRECT   = 3'd5  // при обращении к хранилищу монет
} coin_nominal;
```
Хранилище монет. При опускании монеты подходящего номинала, хранилище пополняется, во время выдачи сдачи или опустошения хранилища сотрудником, оно опустевает, по одной монете за транзакцию.  
В случае опустошения хранилища по сервисному запросу, хранилище автоматически пополняется двадцатью монетами каждого номинала. Если в автомате находится менее 10 монет какого-либо номинала, автомат считает себя не способным выдать сдачу и переходит в состояние `MAINTENANCE`.

## item_storage
``` SystemVerilog
localparam  PRICE       = 1'b0,
            COUNT       = 1'b1;
logic [6:0] item_storage[2][8];
//                       ^  ^
//                       |  |- item id
//                       |- PRICE / COUNT
```
Хранилище товаров. В рабочем состоянии, содержимое может только уменьшаться из состояния `SERV` по завершению транзакции выдачи товара. Пополнение происходит одновременно с пополнением хранилища монет (по выходу из состояния `EJECT` при сервисном сбросе).

## current_balance
``` SystemVerilog
logic [31:0] current_balance;
```
Текущий депозит. Увеличивается при попадании в состояние `INCREMENT`. По переходу в состояние `SERV` обнуляется, т.к. вне зависимости от того, совершится покупка или нет, будет либо выдан товар со сдачей или без, либо возвращён депозит.

## exchange
``` SystemVerilog
logic [31:0] exchange;
```
Регистр сдачи. Используется как при выдачи сдачи, так и при возврате депозита. Выставляется исключительно в состоянии `SERV`. В случае совершения продажи, вычисляется разность между стоимостью товара и депозитом, в противном случае, приравнивается депозиту.  
Во время этапа выдачи монет, уменьшается на соответствующий выдаваемой монете номинал.